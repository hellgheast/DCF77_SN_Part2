--------------------------------------------------------------------------------
--
-- This VHDL file was generated by EASE/HDL 8.0 Revision 2 from HDL Works B.V.
--
-- Ease library  : design_dcf_complete
-- HDL library   : design_dcf_complete
-- Host name     : INF13-BENSALAHM
-- User name     : mohammed.bensalah
-- Time stamp    : Sun Jun 07 20:13:05 2015
--
-- Designed by   : 
-- Company       : 
-- Project info  : 
--
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
-- Object        : Entity design_dcf_complete.kcuart_tx
-- Last modified : Sat Jun 06 15:29:37 2015.
--------------------------------------------------------------------------------



library ieee, unisim;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_arith.ALL;
use ieee.std_logic_unsigned.ALL;
use unisim.VCOMPONENTS.ALL;

entity kcuart_tx is
  port (
    data_in        : in     std_logic_vector(7 downto 0);
    send_character : in     std_logic;
    en_16_x_baud   : in     std_logic;
    serial_out     : out    std_logic;
    Tx_complete    : out    std_logic;
    clk            : in     std_logic);
end entity kcuart_tx;

--------------------------------------------------------------------------------
-- Object        : Architecture design_dcf_complete.kcuart_tx.low_level_definition
-- Last modified : Sat Jun 06 15:29:37 2015.
--------------------------------------------------------------------------------

architecture low_level_definition of kcuart_tx is

  signal data_01            : std_logic;
  signal data_23            : std_logic;
  signal data_45            : std_logic;
  signal data_67            : std_logic;
  signal data_0123          : std_logic;
  signal data_4567          : std_logic;
  signal data_01234567      : std_logic;
  signal bit_select         : std_logic_vector(2 downto 0);
  signal next_count         : std_logic_vector(2 downto 0);
  signal mask_count         : std_logic_vector(2 downto 0);
  signal mask_count_carry   : std_logic_vector(2 downto 0);
  signal count_carry        : std_logic_vector(2 downto 0);
  signal ready_to_start     : std_logic;
  signal decode_Tx_start    : std_logic;
  signal Tx_start           : std_logic;
  signal decode_Tx_run      : std_logic;
  signal Tx_run             : std_logic;
  signal decode_hot_state   : std_logic;
  signal hot_state          : std_logic;
  signal hot_delay          : std_logic;
  signal Tx_bit             : std_logic;
  signal decode_Tx_stop     : std_logic;
  signal Tx_stop            : std_logic;
  signal decode_Tx_complete : std_logic;
  attribute INIT : string;
  attribute INIT of mux1_lut      : label is "E4FF";
  attribute INIT of mux2_lut      : label is "E4FF";
  attribute INIT of mux3_lut      : label is "E4FF";
  attribute INIT of mux4_lut      : label is "E4FF";
  attribute INIT of ready_lut     : label is "10";
  attribute INIT of start_lut     : label is "0190";
  attribute INIT of run_lut       : label is "1540";
  attribute INIT of hot_state_lut : label is "94";
  attribute INIT of delay14_srl   : label is "0000";
  attribute INIT of stop_lut      : label is "0180";
  attribute INIT of complete_lut  : label is "8";

begin
  count_width_loop: for i in 0 to 2 generate
      attribute INIT : string;
      attribute INIT of count_lut : label is "8";

  begin
      lsb_count: if (i = 0) generate
      begin

          count_muxcy: MUXCY
            port map(
              O  => count_carry(i),
              CI => Tx_bit,
              DI => mask_count_carry(i),
              S  => mask_count(i));

          count_xor: XORCY
            port map(
              O  => next_count(i),
              CI => Tx_bit,
              LI => mask_count(i));
      end generate lsb_count;
      upper_count: if (i > 0) generate
      begin

          count_muxcy: MUXCY
            port map(
              O  => count_carry(i),
              CI => count_carry(i-1),
              DI => mask_count_carry(i),
              S  => mask_count(i));

          count_xor: XORCY
            port map(
              O  => next_count(i),
              CI => count_carry(i-1),
              LI => mask_count(i));
      end generate upper_count;

      register_bit: FDRE
        generic map(
          INIT => '0')
        port map(
          Q  => bit_select(i),
          C  => clk,
          CE => en_16_x_baud,
          D  => next_count(i),
          R  => Tx_start);

      count_lut: LUT2
        generic map(
          INIT => X"0")
        port map(
          O  => mask_count(i),
          I0 => bit_select(i),
          I1 => Tx_run);

      mask_and: MULT_AND
        port map(
          LO => mask_count_carry(i),
          I0 => bit_select(i),
          I1 => Tx_run);
  end generate count_width_loop;

  mux1_lut: LUT4
    generic map(
      INIT => X"0000")
    port map(
      O  => data_01,
      I0 => bit_select(0),
      I1 => data_in(0),
      I2 => data_in(1),
      I3 => Tx_run);

  mux2_lut: LUT4
    generic map(
      INIT => X"0000")
    port map(
      O  => data_23,
      I0 => bit_select(0),
      I1 => data_in(2),
      I2 => data_in(3),
      I3 => Tx_run);

  mux3_lut: LUT4
    generic map(
      INIT => X"0000")
    port map(
      O  => data_45,
      I0 => bit_select(0),
      I1 => data_in(4),
      I2 => data_in(5),
      I3 => Tx_run);

  mux4_lut: LUT4
    generic map(
      INIT => X"0000")
    port map(
      O  => data_67,
      I0 => bit_select(0),
      I1 => data_in(6),
      I2 => data_in(7),
      I3 => Tx_run);

  mux5_muxf5: MUXF5
    port map(
      O  => data_0123,
      I0 => data_01,
      I1 => data_23,
      S  => bit_select(1));

  mux6_muxf5: MUXF5
    port map(
      O  => data_4567,
      I0 => data_45,
      I1 => data_67,
      S  => bit_select(1));

  mux7_muxf6: MUXF6
    port map(
      O  => data_01234567,
      I0 => data_0123,
      I1 => data_4567,
      S  => bit_select(2));

  pipeline_serial: FDRS
    generic map(
      INIT => '0')
    port map(
      Q => serial_out,
      C => clk,
      D => data_01234567,
      R => Tx_start,
      S => Tx_stop);

  ready_lut: LUT3
    generic map(
      INIT => X"00")
    port map(
      O  => ready_to_start,
      I0 => Tx_run,
      I1 => Tx_start,
      I2 => send_character);

  start_lut: LUT4
    generic map(
      INIT => X"0000")
    port map(
      O  => decode_Tx_start,
      I0 => Tx_bit,
      I1 => Tx_stop,
      I2 => ready_to_start,
      I3 => Tx_start);

  Tx_start_reg: FDE
    generic map(
      INIT => '0')
    port map(
      Q  => Tx_start,
      C  => clk,
      CE => en_16_x_baud,
      D  => decode_Tx_start);

  run_lut: LUT4
    generic map(
      INIT => X"0000")
    port map(
      O  => decode_Tx_run,
      I0 => count_carry(2),
      I1 => Tx_bit,
      I2 => Tx_start,
      I3 => Tx_run);

  Tx_run_reg: FDE
    generic map(
      INIT => '0')
    port map(
      Q  => Tx_run,
      C  => clk,
      CE => en_16_x_baud,
      D  => decode_Tx_run);

  hot_state_lut: LUT3
    generic map(
      INIT => X"00")
    port map(
      O  => decode_hot_state,
      I0 => Tx_stop,
      I1 => ready_to_start,
      I2 => Tx_bit);

  hot_state_reg: FDE
    generic map(
      INIT => '0')
    port map(
      Q  => hot_state,
      C  => clk,
      CE => en_16_x_baud,
      D  => decode_hot_state);

  delay14_srl: SRL16E
    generic map(
      INIT => X"0000")
    port map(
      Q   => hot_delay,
      A0  => '1',
      A1  => '0',
      A2  => '1',
      A3  => '1',
      CE  => en_16_x_baud,
      CLK => clk,
      D   => hot_state);

  Tx_bit_reg: FDE
    generic map(
      INIT => '0')
    port map(
      Q  => Tx_bit,
      C  => clk,
      CE => en_16_x_baud,
      D  => hot_delay);

  stop_lut: LUT4
    generic map(
      INIT => X"0000")
    port map(
      O  => decode_Tx_stop,
      I0 => Tx_bit,
      I1 => Tx_run,
      I2 => count_carry(2),
      I3 => Tx_stop);

  Tx_stop_reg: FDE
    generic map(
      INIT => '0')
    port map(
      Q  => Tx_stop,
      C  => clk,
      CE => en_16_x_baud,
      D  => decode_Tx_stop);

  complete_lut: LUT2
    generic map(
      INIT => X"0")
    port map(
      O  => decode_Tx_complete,
      I0 => count_carry(2),
      I1 => en_16_x_baud);

  Tx_complete_reg: FD
    generic map(
      INIT => '0')
    port map(
      Q => Tx_complete,
      C => clk,
      D => decode_Tx_complete);
end architecture low_level_definition ; -- of kcuart_tx

